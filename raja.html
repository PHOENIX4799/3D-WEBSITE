<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Air-Traffic Style Particles — Cyber Nexus</title>
    <style>
        :root {
            --bg: #000000ff;
            --accent: #00CED1;
            --panel: rgba(13, 13, 13, 0.821);
            --text: rgba(255, 255, 255, 0.95);
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
            color: var(--text);
        }

        /* Fullscreen canvas background (behind content) */
        canvas#bg {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            display: block;
            pointer-events: none;
        }

        /* Page content */
        .page {
            position: relative;
            z-index: 1;
            max-width: 1100px;
            margin: 28px auto;
            padding: 20px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
        }

        h1 {
            margin: 0;
            font-size: 20px;
        }

        .controls {
            background: var(--panel);
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
            box-shadow: 0px 3px 6px #00CED1;
            border-radius: 10px;
            padding: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            border: 1px solid rgba(230, 16, 16, 0.04);
        }

        .controls label {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.85);
        }

        .controls input[type="range"] {
            width: 140px;
        }

        button {
            background: rgba(255, 255, 255, 0.04);
            color: var(--text);
            border: 1px solid rgba(255, 255, 255, 0.06);
            padding: 8px 10px;
            border-radius: 8px;
            cursor: pointer;
        }

        .card {
            margin-top: 20px;
            background: rgba(255, 255, 255, 0.03);
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
            padding: 16px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.04);
        }

        .small {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.7);
        }

        .settings-container {
            display: flex;
            height: 100vh;
            background: #f5f6fa;
        }

        /* Sidebar */
        .sidebar {
            width: 250px;
            background: #1e1e2f;
            color: #fff;
            padding: 20px;
        }

        .sidebar-title {
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
            text-align: center;
            color: #00b4d8;
        }

        .sidebar-menu {
            list-style: none;
        }

        .sidebar-menu li {
            padding: 12px 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .sidebar-menu li:hover {
            background: #2c2c44;
        }

        .sidebar-menu li.active {
            background: #00b4d8;
            color: #fff;
        }

        /* Main content */
        .settings-content {
            flex: 1;
            padding: 40px;
        }

        footer {
            margin-top: 28px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 13px;
        }
    </style>
</head>

<body>
    <canvas id="bg"></canvas>

    <div class="page">
        <header>
            <div>
                <h1>Air-Traffic / Night-Sky Particles — Cyber Nexus</h1>
                <div class="small">Dots move in 8 discrete directions, lines connect within 100px.</div>
            </div>

            <div class="controls" aria-hidden="false">
                <label>Count
                    <input id="countRange" type="range" min="50" max="900" step="10" value="300">
                </label>
                <label>Speed
                    <input id="speedRange" type="range" min="0.2" max="3.2" step="0.1" value="1.0">
                </label>
                <label style="display:flex;align-items:center;gap:6px">
                    <input id="mouseToggle" type="checkbox" checked> Mouse repel
                </label>
                <button id="regen">Regenerate</button>
            </div>
        </header>

        <div class="settings-container">
            <aside class="sidebar">
                <h2 class="sidebar-title">Settings</h2>
                <ul class="sidebar-menu">
                    <li class="active"><i class="bx bx-user"></i> Profile</li>
                    <li><i class="bx bx-lock"></i> Security</li>
                    <li><i class="bx bx-bell"></i> Notifications</li>
                    <li><i class="bx bx-palette"></i> Appearance</li>
                    <li><i class="bx bx-log-out"></i> Logout</li>
                </ul>
            </aside>

            <main class="settings-content">
                <h1>Profile Settings</h1>
                <p>Here you can update your profile info...</p>
            </main>
        </div>

        <div class="card">
            <h3 style="margin-top:0">About</h3>
            <p class="small">This canvas is behind content (pointer events disabled). Increase particle count or speed
                from the controls. Use the regenerate button to re-seed positions and directions.</p>
        </div>

        <footer>Made for <strong>Phoenix</strong> — tweak constants in the script to suit visual intensity.</footer>
    </div>

    <script>
        (() => {
            // Canvas + DPR setup
            const canvas = document.getElementById('bg');
            const ctx = canvas.getContext('2d', { alpha: true });

            let DPR = Math.max(1, window.devicePixelRatio || 1);
            function resize() {
                DPR = Math.max(1, window.devicePixelRatio || 1);
                canvas.width = Math.floor(window.innerWidth * DPR);
                canvas.height = Math.floor(window.innerHeight * DPR);
                canvas.style.width = window.innerWidth + 'px';
                canvas.style.height = window.innerHeight + 'px';
                ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
            }
            window.addEventListener('resize', resize);
            resize();

            // Configuration (easy to tune)
            const CONFIG = {
                particleCount: 300,       // default
                maxLinkDist: 130,         // max distance for a connection line
                baseLineAlpha: 0.22,
                particleBaseSize: 2.4,
                speedFactor: 1.0,         // multiplied by direction magnitude
                dirChangeChancePerSec: 0.08, // probability per second that a particle chooses a new discrete direction
                mouseInfluence: 70,      // px
                mouseForce: 22            // repulsion strength
            };

            // Direction vectors — 8 cardinal / diagonal directions (normalized)
            const SQ = Math.SQRT1_2; // 1/sqrt(2) ≈ 0.7071
            const DIRS = [
                { x: 1, y: 0 },    // E
                { x: -1, y: 0 },    // W
                { x: 0, y: 1 },    // S
                { x: 0, y: -1 },    // N
                { x: SQ, y: SQ },  // SE
                { x: -SQ, y: SQ },  // SW
                { x: SQ, y: -SQ },  // NE
                { x: -SQ, y: -SQ },  // NW
            ];

            // State
            let particles = [];
            let grid = null;
            let last = performance.now();
            let mouse = { x: -9999, y: -9999 };
            let mouseRepelEnabled = true;

            // UI elements
            const countRange = document.getElementById('countRange');
            const speedRange = document.getElementById('speedRange');
            const regenBtn = document.getElementById('regen');
            const mouseToggle = document.getElementById('mouseToggle');

            // Listen for mouse (canvas is pointer-events none so track window mouse)
            window.addEventListener('mousemove', (e) => {
                mouse.x = e.clientX;
                mouse.y = e.clientY;
            });
            window.addEventListener('mouseleave', () => {
                mouse.x = -9999;
                mouse.y = -9999;
            });

            // Utility
            const rand = (a, b) => (Math.random() * (b - a) + a);
            const choose = (arr) => arr[Math.floor(Math.random() * arr.length)];
            const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
            function dist2(ax, ay, bx, by) { const dx = ax - bx, dy = ay - by; return dx * dx + dy * dy; }

            // Spatial grid for neighbor queries (simple uniform grid)
            class SpatialGrid {
                constructor(cellSize) {
                    this.cellSize = cellSize;
                    this.cols = Math.ceil(window.innerWidth / cellSize);
                    this.rows = Math.ceil(window.innerHeight / cellSize);
                    this.cells = new Map(); // key: `${col},${row}` => array of particles
                }
                clear() {
                    this.cells.clear();
                }
                _key(col, row) { return col + ',' + row; }
                insert(p) {
                    const col = Math.floor(p.x / this.cellSize);
                    const row = Math.floor(p.y / this.cellSize);
                    const key = this._key(col, row);
                    if (!this.cells.has(key)) this.cells.set(key, []);
                    this.cells.get(key).push(p);
                    p._gridCell = { col, row };
                }
                nearby(p) {
                    // return particles in same or adjacent cells
                    const out = [];
                    const c = p._gridCell ? p._gridCell.col : Math.floor(p.x / this.cellSize);
                    const r = p._gridCell ? p._gridCell.row : Math.floor(p.y / this.cellSize);
                    for (let dc = -1; dc <= 1; dc++) {
                        for (let dr = -1; dr <= 1; dr++) {
                            const key = this._key(c + dc, r + dr);
                            const arr = this.cells.get(key);
                            if (arr) out.push(...arr);
                        }
                    }
                    return out;
                }
            }

            // Particle
            class Particle {
                constructor(w, h) {
                    this.reset(w, h);
                }
                reset(w, h) {
                    this.x = rand(0, w);
                    this.y = rand(0, h);
                    const dir = choose(DIRS);
                    this.vx = dir.x;
                    this.vy = dir.y;
                    const speed = rand(0.45, 1.15);
                    this.speed = speed;
                    this.size = CONFIG.particleBaseSize * (0.85 + Math.random() * 0.6);
                    this.color = '#00CED1';
                }
                step(dt, w, h) {
                    // occasional discrete direction change
                    const chance = CONFIG.dirChangeChancePerSec * (dt / 1000);
                    if (Math.random() < chance) {
                        const d = choose(DIRS);
                        this.vx = d.x;
                        this.vy = d.y;
                        // small speed variation
                        this.speed = clamp(this.speed + rand(-0.18, 0.18), 0.2, 2.6);
                    }

                    // mouse repulsion (optional)
                    if (mouseRepelEnabled && mouse.x > -9000) {
                        const dx = this.x - mouse.x;
                        const dy = this.y - mouse.y;
                        const d2 = dx * dx + dy * dy;
                        const r = CONFIG.mouseInfluence;
                        if (d2 < r * r && d2 > 0.0001) {
                            const d = Math.sqrt(d2);
                            const push = (1 - (d / r)) * CONFIG.mouseForce * (dt / 16.666);
                            // add to velocity vector direction
                            this.x += (dx / d) * push;
                            this.y += (dy / d) * push;
                        }
                    }

                    // integrate movement in straight line
                    this.x += this.vx * this.speed * CONFIG.speedFactor * (dt / 16.666);
                    this.y += this.vy * this.speed * CONFIG.speedFactor * (dt / 16.666);

                    // bounce off edges
                    if (this.x <= 0) { this.x = 0; this.vx = -this.vx; }
                    if (this.x >= w) { this.x = w; this.vx = -this.vx; }
                    if (this.y <= 0) { this.y = 0; this.vy = -this.vy; }
                    if (this.y >= h) { this.y = h; this.vy = -this.vy; }
                }
                draw(ctx) {
                    // glow
                    ctx.beginPath();
                    ctx.fillStyle = 'rgba(46, 241, 255, 0.05)';
                    ctx.arc(this.x, this.y, this.size * 3.2, 0, Math.PI * 2);
                    ctx.fill();
                    // core
                    ctx.beginPath();
                    ctx.fillStyle = this.color;
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Initialize / regenerate
            function initParticles(count) {
                particles = [];
                for (let i = 0; i < count; i++) particles.push(new Particle(innerWidth, innerHeight));
                grid = new SpatialGrid(CONFIG.maxLinkDist);
            }

            // Main loop
            function animate(now) {
                const dt = now - last;
                last = now;

                // clear + backdrop subtle gradient
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const g = ctx.createLinearGradient(0, 0, 0, innerHeight);
                g.addColorStop(0, 'rgba(4,10,22,0.06)');
                g.addColorStop(1, 'rgba(1,3,8,0.12)');
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, innerWidth, innerHeight);

                // step particles and populate grid
                grid.clear();
                for (const p of particles) {
                    p.step(dt, innerWidth, innerHeight);
                    grid.insert(p);
                }

                // ---------- Helpers (paste once near top) ----------
                function hexToRgb(hex) {
                    let h = hex.replace(/^#/, '').trim();
                    if (h.length === 3) h = h.split('').map(c => c + c).join('');
                    if (h.length === 8) h = h.slice(0, 6); // drop alpha if provided
                    const r = parseInt(h.slice(0, 2), 16);
                    const g = parseInt(h.slice(2, 4), 16);
                    const b = parseInt(h.slice(4, 6), 16);
                    return { r, g, b };
                }
                // choose the hex color you want here:
                const LINE_HEX = '#00CED1';         // <- change this to any hex
                const LINE_RGB = hexToRgb(LINE_HEX);
                // ---------- end helpers ----------

                // draw connections (each pair only once) - hex + alpha friendly
                const maxD2 = CONFIG.maxLinkDist * CONFIG.maxLinkDist;
                ctx.lineWidth = 1;

                for (const p of particles) {
                    const neighbors = grid.nearby(p);
                    for (const q of neighbors) {
                        if (q === p) continue;
                        if (p._index >= q._index) continue; // draw pair only once
                        const d2 = dist2(p.x, p.y, q.x, q.y);
                        if (d2 <= maxD2) {
                            const d = Math.sqrt(d2);
                            // linear fade (0..1) — change to Math.pow(t,2) for sharper falloff, etc.
                            let alpha = (1 - (d / CONFIG.maxLinkDist)) * CONFIG.baseLineAlpha;
                            alpha = Math.max(0, Math.min(CONFIG.baseLineAlpha, alpha)); // clamp

                            // fast rgba from cached rgb
                            ctx.strokeStyle = `rgba(${LINE_RGB.r},${LINE_RGB.g},${LINE_RGB.b},${alpha})`;
                            ctx.beginPath();
                            ctx.moveTo(p.x, p.y);
                            ctx.lineTo(q.x, q.y);
                            ctx.stroke();
                        }
                    }
                }

                // draw particles (on top of lines)
                for (const p of particles) p.draw(ctx);

                requestAnimationFrame(animate);
            }

            // Assign _index for double-draw avoidance and start
            function startLoop() {
                for (let i = 0; i < particles.length; i++) particles[i]._index = i;
                last = performance.now();
                requestAnimationFrame(animate);
            }

            // UI wiring
            countRange.addEventListener('input', e => {
                const val = Number(e.target.value);
                CONFIG.particleCount = val;
            });

            speedRange.addEventListener('input', e => {
                const v = Number(e.target.value);
                CONFIG.speedFactor = v;
            });

            mouseToggle.addEventListener('change', () => {
                mouseRepelEnabled = mouseToggle.checked;
            });

            regenBtn.addEventListener('click', () => {
                initParticles(CONFIG.particleCount);
                startLoop();
            });

            // initial boot
            initParticles(CONFIG.particleCount);
            startLoop();

            // handle visibility change to pause rendering when tab hidden (conserve CPU)
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    // no-op: animationFrame will stop naturally; but we can reduce updates if desired
                } else {
                    // resume loop time sync
                    last = performance.now();
                }
            });

            // expose a small API for debugging in console
            window._airTraffic = {
                config: CONFIG,
                particles,
                regen: () => { initParticles(CONFIG.particleCount); startLoop(); }
            };
        })();
    </script>
</body>

</html>